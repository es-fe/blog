<br>

#### 前言
近几年，前端社区中 DSL 这个词开始频繁出镜，这和环境的变化有很大关系：
1. React、Vue、Angular 等现代框架的表现层设计往往和 DSL 有较强的关联，透过这些优秀作品我们可以得到一些实践指引。
2. 前端相关语言的转编译工具链趋于成熟，如 babel，postcss 等工具可以帮助开发者以扩展插件的方式低成本地参与到语言构建流程中。
3. 社区的解析器生成工具开始普及。如[json](https://github.com/zaach/jison)、[PEG.js](https://link.zhihu.com/?target=https%3A//pegjs.org/)

#### DSL初识
> 和很多计算机领域的概念一样，DSL其实也算是先有实践再有定义。
> 一种为**特定领域**设计的，具有**受限表达性**的**编程语言**

DSL即[Domain Specific Language], 中文一般译为[领域特定语言]

![](https://pic1.zhimg.com/80/v2-6c0629a04ad5e6859c0499f71082ec24_720w.jpg)
如上图所示，汇编语言通过助记符代替机器指令操作码，极大的增强了机器语言的可读性和可维护性。但本质上它仍是一门面向处理器和寄存器等硬件系统的低级编程语言。
高级语言的出现解决了这个问题，真正脱离了对机器指令集的直接关联，以上层抽象的语句(流程控制、循环等)和数据结构等更趋近自然语言和数学公式的方式完成编码工作，大大提升了程序开发的效率。

但在高级语言层面，抽象带来的效率提升似乎有了天花板。无论是从 C 到 Java，抑或是各种编程范式下衍生的抽象度更高的编程语言，解决的都是通用编程问题，它们都有充分的过程抽象和数据抽象，
导致大量的概念产生，进而影响了编程效率。

而在一些专有领域的任务处理上其实不需要那么多语言特性，DSL 就是在这种矛盾中产生的破局方案，它是为了解决特定任务的语言工具，比如文档编写有 markdown，
字符串匹配有 RegExp，任务控制有 make、gradle，数据查找有 SQL，Web 样式编码有 CSS 等等。它的本质其实和我们很多软件工程问题的解决思路一样，
**通过限定问题域边界，从而锁定复杂度，提高编程效率**。

我们先来个简单的例子， 比如表示**2周前的时间：**

**解法一**
```
new Date(Date.now() - 1000 * 60 * 60 * 24 * 7 * 2)
```

**解法二**
```
2 weeks().ago()
```

**解法三**
```
(2).weeks().ago();
```


解法一是符合通用编程思维的解答，但即使作为程序员的我们也无法一眼看出其含义。

解法二和解法三其实就是 DSL 的两种不同类型——外部 DSL 和内部 DSL，它们的直观性显然更高（不信可以问问你的女朋友），但它却无法直接运行，
假如你尝试在 JavaScript 环境下运行它，将会获得完全不同的错误：

- `2 weeks ago`会得到`Uncaught SyntaxError: Unexpected identifier`的**语法错误**
- `(2).weeks().ago()`会得到一个`Uncaught TypeError: 2.weeks is not a function`的**运行时类型错误**。

> 其实从错误类型上我们就可以看到它们是有本质不同的。
